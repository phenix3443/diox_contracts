import IAuthMessage;
import ISubProtocol;
import AMLib;
import Utils;

contract AuthMsg implements IAuthMessage.AuthMessageInterface {

    struct SubProtocol {
        uint32 protocolType;
        address protocolAddress;
        bool exist;
    }

    @global address owner;
    @global address relayer;

    @global map<address, SubProtocol> subProtocols;
    @global map<uint32, address> protocolRoutes;

    @global function on_deploy(address _owner, address _relayer) {
        owner = _owner;
        relayer = _relayer;

        __debug.print("[on_deploy] AuthMsg deployed - address:", __address(), " id:", __id());
        __debug.print("[on_deploy] Owner:", owner, " Relayer:", relayer);
    }

    @address function setRelayer(address _relayer) public export {
        __debug.assert(__transaction.get_sender() == owner);
        relay@global (^_relayer){
            relayer = _relayer;
        }
    }

    // 注意：SDPMsg 会在其 on_deploy 中自动调用此函数注册自己
    // 此函数也可用于注册其他协议或重新配置现有协议
    @address function setProtocol(uint64 protocolID, address protocolAddress, uint32 protocolType) public export {
        __debug.assert(__transaction.get_sender() == owner);
        __debug.assert(!subProtocols[protocolAddress].exist);
        relay@global (^protocolID, ^protocolAddress, ^protocolType) {
            SubProtocol p;
            p.exist = true;
            p.protocolType = protocolType;
            p.protocolAddress = protocolAddress;
            subProtocols[protocolAddress] = p;
            protocolRoutes[protocolType] = protocolAddress;
            __debug.print("[setProtocol] Protocol registered - type:", protocolType, " id:", protocolID, " address:", protocolAddress);
            __debug.print("[Event] SubProtocolUpdate - type:", protocolType, " id:", protocolID);
        }
    }

    @global function recvFromProtocol(uint64 senderID, array<uint8> message) public export{
        address protocol = __transaction.get_sender();
        __debug.assert(subProtocols[protocol].exist);

        // use version 1 for now
        AMLib.AuthMessage amV1;
        amV1.version = 1u32;
        amV1.author = Utils.uint256ToBytes32(uint256(senderID));
        amV1.protocolType = subProtocols[protocol].protocolType;
        amV1.body = Utils.bytesCopy(message);

        array<uint8> AMMsg = AMLib.encodeAuthMessage(amV1);
        __debug.print("[recvFromProtocol] AuthMsg encoded: ", AMMsg);
        relay@external SendAuthMessage(AMMsg);
    }

    @address function recvPkgFromRelayer(array<uint8> pkg) public export {
        __debug.assert(__transaction.get_sender() == relayer);

        __debug.print("[recvPkgFromRelayer] Received UCP package, length: ", pkg.length());

        // 1. 解码 MessageFromRelayer，获取 senderDomain 和 rawResp (AuthMessage bytes)
        AMLib.DecodeResult dr = AMLib.decodeMessageFromRelayer(pkg);
        __debug.print("[recvPkgFromRelayer] senderDomain: ", dr.senderDomain);
        __debug.print("[recvPkgFromRelayer] rawResp length: ", dr.rawResp.length());

        // 2. 解码 AuthMessage
        AMLib.AuthMessage msg = AMLib.decodeAuthMessage(dr.rawResp);
        __debug.print("[recvPkgFromRelayer] Decoded AuthMessage, protocolType: ", msg.protocolType);
        __debug.print("[recvPkgFromRelayer] author: ", msg.author);

        // 3. 验证协议路由存在
        address zeroAddress;
        __debug.assert(protocolRoutes[msg.protocolType] != zeroAddress);

        // 4. 触发接收事件
        relay@external recvAuthMessage(dr.senderDomain, dr.rawResp);

        // 5. 调用上层协议（SDPMsg）的 recvMessage
        relay@global (^msg, ^dr) {
            address protocolAddr = protocolRoutes[msg.protocolType];
            ISubProtocol.SubProtocolInterface sdp = ISubProtocol.SubProtocolInterface(protocolAddr);
            sdp.recvMessage(dr.senderDomain, msg.author, msg.body);
        }

        __debug.print("[recvPkgFromRelayer] Message routed successfully");
    }

    @global function address getProtocol(uint32 protocolType) export const {
        return protocolRoutes[protocolType];
    }

}