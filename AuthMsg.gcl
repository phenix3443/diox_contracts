// import IAuthMessage;
import AMLib;
import Utils;

// contract AuthMsg implements IAuthMessage.IAuthMessageV1 {
contract AuthMsg {

    struct SubProtocol {
        uint32 protocolType;
        address protocolAddress;
        bool exist;
    }

    @global address owner;
    @global address relayer;

    @global map<address, SubProtocol> subProtocols;
    @global map<uint32, address> protocolRoutes;

    @global function on_deploy(address _owner, address _relayer) {
        owner = _owner;
        relayer = _relayer;
        __debug.print("address:", __address(),"  cid:",__id());
        __debug.print("owner:", owner,"  relayer:", relayer);
    }

    @address function setRelayer(address _relayer) public export {
        __debug.assert(__transaction.get_sender() == owner);
        relay@global (^_relayer){
            relayer = _relayer;
        }
    }

    @address function setProtocol(uint64 protocolID, address protocolAddress, uint32 protocolType) public export {
        __debug.assert(__transaction.get_sender() == owner);
        __debug.assert(!subProtocols[protocolAddress].exist);
        relay@global (^protocolID, ^protocolAddress, ^protocolType) {
            SubProtocol p;
            p.exist = true;
            p.protocolType = protocolType;
            p.protocolAddress = protocolAddress;
            subProtocols[protocolAddress] = p;
            protocolRoutes[protocolType] = protocolAddress;
            __debug.print("protocol type: ",protocolType,"  protocol id: ",protocolID, " protocol address: ", protocolAddress);
            relay@external SubProtocolUpdate(protocolType, protocolID);
        }
    }

    @address function recvFromProtocol(uint64 senderID, array<uint8> message) public export{
        // address protocol = __transaction.get_sender();
        // __debug.assert(subProtocols[protocol].exist);

        // use version 1 for now
        AMLib.AuthMessage amV1;
        amV1.version = 1u32;
        amV1.author = Utils.uint256ToBytes32(uint256(senderID));
        // amV1.protocolType = subProtocols[protocol].protocolType;
        amV1.protocolType = 1u32; // hardcode for testing
        amV1.body = Utils.bytesCopy(message);

        // __debug.print("amV1: ", amV1);

        array<uint8> AMMsg = AMLib.encodeAuthMessage(amV1);
        __debug.print("AuthMsg: ", AMMsg);
        relay@external SendAuthMessage(AMMsg);
    }

    @address function recvPkgFromRelayer(array<uint8> pkg) public export {
        // __debug.assert(__transaction.get_sender() == relayer);
        // AMLib.MessageFromRelayer r;
        // AMLib.decodeMessageFromRelayer(pkg,r);
        // AMLib.MessageForAM messageForAM = AMLib.decode(pkg);
        // __debug.print(messageForAM);

        // AMLib.AuthMessage msg = AMLib.decodeAuthMessage(messageForAM.rawMessage);
        AMLib.AuthMessage msg = AMLib.decodeAuthMessage(pkg); // only test decode AM Msg
        __debug.print("Decoded AuthMessage: ", msg);
        // address zeroAddress;
        // __debug.assert(protocolRoutes[msg.protocolType] != zeroAddress);
        // __debug.print(msg);
        // relay@external recvAuthMessage(messageForAM.senderDomain, messageForAM.rawMessage);

        // call upper protocol
        
        // ISubProtocol.ISubProtocolV1 sdp = ISubProtocol.ISubProtocolV1(protocolRoutes[msg.protocolType].__id());
        // sdp.recvMessage(domain, msg.author, msg.body);
    }
    
}