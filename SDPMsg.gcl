import SDPLib;
// import IAuthMessage;
// import IContractUsingSDP;
// import ISDPMessage;
import Utils;

// contract SDPMsg implements ISDPMessage.ISDPMessageV1, ISubProtocol.ISubProtocolV1 {
contract SDPMsg {

    @global address owner;

    @global uint64 amContractId;
    @global address amAddress;
    @global array<uint8> localDomain;

    @address map<hash, uint32> sendSeq;
    // map<hash, uint32> recvSeq;

    const uint32 UNORDERED_SEQUENCE = 0xffffffffu32;

    // @notice only for orderred msg
    const uint64 MAX_NONCE = 0xffffffffffffffffu64;

    @global function on_deploy(address _owner) {
        owner = _owner;
        __debug.print("address: ",__address()," cid:",__id());
    }

    @address function setAmContract(uint64 _amContractId, address _amAddress) public export {
        __debug.assert(__transaction.get_sender() == owner);
        relay@global (^_amContractId, ^_amAddress) {
            amContractId = _amContractId;
            amAddress = _amAddress;
            __debug.print("[setAmContract] amContractId: ", amContractId, " amAddress: ", amAddress);
        }
    }

    @address function setLocalDomain(array<uint8> domain) public export {
        __debug.assert(__transaction.get_sender() == owner);
        relay@global (^domain) {
            localDomain = domain;
            __debug.print("setLocalDomain: ", localDomain);
        }
    }

    @address function sendMessage(array<uint8> receiverDomain, array<uint8> receiverID, array<uint8> message, uint64 senderID) public export {
        SDPLib.SDPMessage sdpMessage;
        sdpMessage.receiverDomain = Utils.bytesCopy(receiverDomain);
        sdpMessage.receiver = Utils.bytesCopy(receiverID);
        sdpMessage.message = Utils.bytesCopy(message);
        sdpMessage.sequence = _getAndUpdateSendSeq(receiverDomain, senderID, receiverID);

        array<uint8> rawMsg = SDPLib.encodeSDPMsgV1(sdpMessage);
        __debug.print("rawMsg: ", rawMsg);
        // IAuthMessage.IAuthMessageV1 am = IAuthMessage.IAuthMessageV1(amAddress.__id());
        // am.recvFromProtocol(senderID, rawMsg);

    }

    @address function sendUnorderedMessage(array<uint8> receiverDomain, array<uint8> receiverID, array<uint8> message, uint64 senderID) public export {
        SDPLib.SDPMessage sdpMessage;
        sdpMessage.receiverDomain = Utils.bytesCopy(receiverDomain);
        sdpMessage.receiver = Utils.bytesCopy(receiverID);
        sdpMessage.message = Utils.bytesCopy(message);
        sdpMessage.sequence = UNORDERED_SEQUENCE;

        array<uint8> rawMsg = SDPLib.encodeSDPMsgV1(sdpMessage);

        __debug.print("rawMsg: ", rawMsg);

        // IAuthMessage.IAuthMessageV1 am = IAuthMessage.IAuthMessageV1(amAddress.__id());
        // am.recvFromProtocol(, rawMsg);
    }

    @address function recvMessage(array<uint8> senderDomain, array<uint8> senderID, array<uint8> pkg) public export {
        // __debug.assert(__transaction.get_sender() == amAddress);
        // only SDPv1 now
        // uint32 version = SDPLib.getSDPVersionFrom(pkg);
        relay@global (^senderDomain, ^senderID, ^pkg) {
            _processSDPv1(senderDomain, senderID, pkg);   
        }
    }

    @global function _processSDPv1(array<uint8> senderDomain, array<uint8> senderID, array<uint8> pkg) public {
        SDPLib.SDPMessage sdpMessage = SDPLib.decodeSDPMsgV1(pkg);
        __debug.print("sdpMessage: ", sdpMessage);

        __debug.assert(Utils.bytesEqual(sdpMessage.receiverDomain, localDomain));
        
        // if (sdpMessage.sequence == UNORDERED_SEQUENCE) {
        //     _routeUnorderedMessage(senderDomain, senderID, sdpMessage);
        // } else {
        //     _routeOrderedMessage(senderDomain, senderID, sdpMessage);
        // }
    }

    // function _routeUnorderedMessage(array<uint8> senderDomain, array<uint8> senderID, SDPLib.SDPMessage sdpMessage) {
    //     uint64 senderCid = Utils.bytes32ToUint256(senderID);
    //     IContractUsingSDP.IContractUsingSDPV1 dapp = IContractUsingSDP.IContractUsingSDPV1(senderCid);
    //     dapp.recvUnorderedMessage(senderDomain, senderID, sdpMessage.message);
    // }

    // @global function _routeOrderedMessage(array<uint8> senderDomain, array<uint8> senderID, SDPLib.SDPMessage sdpMessage) {
    //     uint32 seqExpected = _getAndUpdateRecvSeq(senderDomain, senderID, sdpMessage.receiver);
    //     __debug.assert(sdpMessage.sequence == seqExpected);

    //     bool res = false;
    //     address zeroAddress;
    //     array<uint8> errMsg;
    //     address receiver = Utils.arrayUint8tToAddress(sdpMessage.receiver);
    //     if (receiver == zeroAddress) {
    //         res = false;
    //         errMsg = "receiver is null";
    //     } else {
    //         address senderAddr = Utils.arrayUint8tToAddress(senderID);
    //         IContractUsingSDP.IContractUsingSDPV1 dapp = IContractUsingSDP.IContractUsingSDPV1(senderAddr.__id());
    //         // check if the bound contract(dapp) implements this interface
    //         if (dapp.__valid() == false) {
    //             res = false;
    //             errMsg = "invalid receiver: not implements crosschain interface[IContractUsingSDP]";
    //         } else {
    //             dapp.recvMessage(senderDomain, senderID, sdpMessage.message);
    //         }
    //     }
    //     relay@external receiveMessage(senderDomain, senderID, receiver, seqExpected, res, errMsg);
    // }


    // @global function uint32 querySDPMessageSeq(array<uint8> senderDomain, array<uint8> senderID, array<uint8> receiverDomain, array<uint8> receiverID) public export {

    // }

    @address function uint32 _getAndUpdateSendSeq(array<uint8> receiverDomain, uint64 senderID, array<uint8> receiver) public {
        hash seqKey = SDPLib.getSendingSeqID(receiverDomain, senderID, receiver);
        uint32 seq = sendSeq[seqKey];
        sendSeq[seqKey]++;
        return seq;
    }

    // @global function uint32 _getAndUpdateRecvSeq(array<uint8> senderDomain, array<uint8> sender, array<uint8> receiver) {
    //     hash seqKey = SDPLib.getReceivingSeqID(senderDomain, sender, receiver);
    //     uint32 seq = recvSeq[seqKey];
    //     recvSeq[seqKey]++;
    //     return seq;
    // }

}